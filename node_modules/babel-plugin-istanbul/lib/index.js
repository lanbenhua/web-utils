"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _fs = require("fs");

var _child_process = require("child_process");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _istanbulLibInstrument = require("istanbul-lib-instrument");

var _testExclude = _interopRequireDefault(require("test-exclude"));

var _schema = _interopRequireDefault(require("@istanbuljs/schema"));

var _parse = require("../utils/parse");

console.log("\nStart babel-plugin-istanbul-shopee...");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function getRealpath(n) {
  try {
    return (
      (0, _fs.realpathSync)(n) ||
      /* istanbul ignore next */
      n
    );
  } catch (e) {
    /* istanbul ignore next */
    return n;
  }
}

const memoize = new Map();
/* istanbul ignore next */

const memosep = _path.default.sep === "/" ? ":" : ";";

function loadNycConfig(cwd, opts) {
  let memokey = cwd;
  const args = [
    _path.default.resolve(__dirname, "load-nyc-config-sync.js"),
    cwd,
  ];

  if ("nycrcPath" in opts) {
    args.push(opts.nycrcPath);
    memokey += memosep + opts.nycrcPath;
  }
  /* execFileSync is expensive, avoid it if possible! */

  if (memoize.has(memokey)) {
    return memoize.get(memokey);
  }

  const result = JSON.parse(
    (0, _child_process.execFileSync)(process.execPath, args)
  );
  const error = result["load-nyc-config-sync-error"];

  if (error) {
    throw new Error(error);
  }

  const config = {
    ..._schema.default.defaults.babelPluginIstanbul,
    cwd,
    ...result,
  };
  memoize.set(memokey, config);
  return config;
}

function findConfig(opts) {
  const cwd = getRealpath(
    opts.cwd ||
      process.env.NYC_CWD ||
      /* istanbul ignore next */
      process.cwd()
  );
  const keys = Object.keys(opts);
  const ignored = Object.keys(opts).filter(
    (s) => s === "nycrcPath" || s === "cwd"
  );

  if (keys.length > ignored.length) {
    // explicitly configuring options in babel
    // takes precedence.
    return { ..._schema.default.defaults.babelPluginIstanbul, cwd, ...opts };
  }

  if (ignored.length === 0 && process.env.NYC_CONFIG) {
    // defaults were already applied by nyc
    return JSON.parse(process.env.NYC_CONFIG);
  }

  return loadNycConfig(cwd, opts);
}

function makeShouldSkip() {
  let exclude;
  return function shouldSkip(file, nycConfig) {
    if (!exclude || exclude.cwd !== nycConfig.cwd) {
      exclude = new _testExclude.default({
        cwd: nycConfig.cwd,
        include: nycConfig.include,
        exclude: nycConfig.exclude,
        extension: nycConfig.extension,
        // Make sure this is true unless explicitly set to `false`. `undefined` is still `true`.
        excludeNodeModules: nycConfig.excludeNodeModules !== false,
      });
    }

    return !exclude.shouldInstrument(file);
  };
}

var dirGitInfo = {};

function execGitCommand(root, subCommand) {
  if (root) {
    subCommand = "-C " + root + subCommand;
  }
  var execRes = _child_process.execSync("git " + subCommand).toString();
  return execRes ? execRes.replace("\n", "") : "";
}

function getCoverGitInfo(config) {
  var root = config.cwd;
  if (Object.keys(dirGitInfo).indexOf(root) == -1) {
    var pid = config.gitProjectId ? config.gitProjectId : 0;
    var commitId = config.commitId ? config.commitId : "";
    var branch = config.branch ? config.branch : "";
    var gitName = config.gitProject ? config.gitProject : "";
    var gitUrl = "";

    if (_fs.existsSync(_path.default.resolve(root, ".git"))) {
      if (!commitId) {
        let commitCommand = " rev-parse HEAD";
        var commitId = execGitCommand(root, commitCommand);
      }
      if (!branch) {
        let branchCommand = " rev-parse --abbrev-ref HEAD";
        branch = execGitCommand(root, branchCommand);
      }
      if (!gitName) {
        let gitUrlCommand = " config --get remote.origin.url";
        var gitUrl = execGitCommand(root, gitUrlCommand);
        if (gitUrl) {
          let temp = gitUrl.split(/\/|\.git/);
          gitName = temp[temp.length - 2];
        }
      }
    }
    if (!commitId) {
      commitId = process.env.GIT_COMMIT ? process.env.GIT_COMMIT : "";
    }

    var gitlabBranch = process.env.CI_COMMIT_BRANCH
      ? process.env.CI_COMMIT_BRANCH
      : "";
    var jenkinsBranch = process.env.GIT_BRANCH ? process.env.GIT_BRANCH : "";

    dirGitInfo[root] = {
      pid: pid,
      commitId: commitId,
      sshAddress: gitUrl,
      gitName: gitName,
      branch: branch,
      jenkinsBranch: jenkinsBranch,
      gitlabBranch: gitlabBranch,
      root: root,
      extension: config.extension,
      include: config.include,
      exclude: config.exclude,
    };
  }
  return dirGitInfo[root];
}

function getVarName(prefix, gitInfo) {
  return prefix + gitInfo["gitName"] + "__" + gitInfo["commitId"];
}

function getJsFileText(varName, fileName, stateMap, onlyText) {
  if (onlyText) {
    return stateMap + "\n";
  }
  var left = "\nwindow" + '["' + varName + '"]';
  var right = stateMap ? stateMap : "{}";
  if (fileName) {
    left = left + '["' + fileName + '"]';
  }
  return left + "=" + right;
}

var _default = (0, _helperPluginUtils.declare)((api) => {
  api.assertVersion(7);
  const shouldSkip = makeShouldSkip();
  const t = api.types;
  return {
    visitor: {
      Program: {
        enter(path, state) {
          if (this.opts.istanbul == false) {
            // 不插桩
            return;
          }
          this.__dv__ = null;
          this.nycConfig = findConfig(this.opts);
          const realPath = getRealpath(this.file.opts.filename);

          if (shouldSkip(realPath, this.nycConfig)) {
            return;
          }

          let { inputSourceMap } = this.opts;

          if (this.opts.useInlineSourceMaps == true) {
            if (!inputSourceMap && this.file.inputMap) {
              inputSourceMap = this.file.inputMap.sourcemap;
            }
          }

          const visitorOptions = {};
          Object.entries(_schema.default.defaults.instrumentVisitor).forEach(
            ([name, defaultValue]) => {
              if (name in this.nycConfig) {
                visitorOptions[name] = this.nycConfig[name];
              } else {
                visitorOptions[name] =
                  _schema.default.defaults.instrumentVisitor[name];
              }
            }
          );

          var coverGitInfo = getCoverGitInfo(this.nycConfig);
          visitorOptions.coverageVariable = getVarName(
            "__coverage__",
            coverGitInfo
          );
          var relativePath = state.filename.replace(
            this.nycConfig.cwd + "/",
            ""
          );

          if (this.nycConfig.extraPath) {
            if (
              this.nycConfig.extraPath.charAt(
                this.nycConfig.extraPath.length - 1
              ) != "/"
            ) {
              this.nycConfig.extraPath = this.nycConfig.extraPath + "/";
            }
            relativePath = this.nycConfig.extraPath + relativePath;
          }

          this.__dv__ = (0, _istanbulLibInstrument.programVisitor)(
            t,
            relativePath,
            { ...visitorOptions, inputSourceMap }
          );

          this.__dv__.enter(path);
          this.coverGitInfo = coverGitInfo;
          this.relativePath = relativePath;
        },

        exit(path, state) {
          if (this.opts.istanbul == false) {
            // 不插桩
            return;
          }
          if (!this.__dv__) {
            return;
          }

          const result = this.__dv__.exit(path);

          if (!result) {
            return;
          }

          if (this.opts.onCover) {
            this.opts.onCover(
              getRealpath(this.file.opts.filename),
              result.fileCoverage
            );
          }

          var stateVarName = getVarName(
            "__coverStatement__",
            this.coverGitInfo
          );
          var gitInfoMap = { gitInfo: this.coverGitInfo };

          if (!this.nycConfig.coverageFile) {
            this.nycConfig.coverageFile = "__coverage__.txt";
          }

          var coverageFileCommit = _path.default.resolve(
            this.coverGitInfo["root"],
            this.nycConfig.coverageFile
          );
          var content = "";
          if (_fs.existsSync(coverageFileCommit)) {
            content = _fs.readFileSync(coverageFileCommit, "utf-8");
            if (
              content.indexOf('"' + this.coverGitInfo["commitId"] + '"') == -1
            ) {
              var initText = getJsFileText(
                stateVarName,
                null,
                JSON.stringify(gitInfoMap),
                true
              );
              _fs.writeFileSync(coverageFileCommit, initText);
            }
          } else {
            var initText = getJsFileText(
              stateVarName,
              null,
              JSON.stringify(gitInfoMap),
              true
            );
            _fs.writeFileSync(coverageFileCommit, initText);
            content = initText;
          }

          var sourceMappings = "";
          if (
            this.file.inputMap &&
            this.file.inputMap.sourcemap &&
            this.file.inputMap.sourcemap.mappings
          ) {
            sourceMappings = this.file.inputMap.sourcemap.mappings;
          }
          var oldLineMap = _parse(
            sourceMappings,
            this.file.ast.comments,
            this.file.code
          );
          oldLineMap = oldLineMap ? oldLineMap : {};

          let fileMap = {};
          fileMap[this.relativePath] = {
            statementMap: result.fileCoverage.statementMap,
            fnMap: result.fileCoverage.fnMap,
            oldLineMap: oldLineMap,
          };
          var appendText = getJsFileText(
            stateVarName,
            null,
            JSON.stringify(fileMap),
            true
          );

          if (content.indexOf(this.relativePath) == -1) {
            _fs.appendFile(coverageFileCommit, appendText, (err) => {
              if (err) {
                console.log("Failed to write coverage data:", err);
              }
            });
          }
        },
      },
    },
  };
});

exports.default = _default;
