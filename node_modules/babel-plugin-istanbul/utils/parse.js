"use strict";

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require("./base64-vlq");

module.exports = function parse(str_, comments, code) {
  var generatedLine = 1,
    previousOriginalLine = 0,
    mappingSeparator = /^[,;]/,
    mappings = {},
    str = str_,
    temp,
    mappingList = [-1],
    commentLines = []; //注释行行号
  // 获取所有注释行行号
  if (comments && comments.length > 0) {
    let codeLines = code.split("\n");
    if (codeLines) {
      for (let i = 0; i < comments.length; i++) {
        let start = comments[i].loc.start.line;
        let end = comments[i].loc.end.line;
        if (comments[i].loc.start.column > 0) {
          if (codeLines.length >= comments[i].loc.start.line) {
            let code = codeLines[comments[i].loc.start.line - 1].substring(
              0,
              comments[i].loc.start.column
            );
            code = code.replace(/\s+/g, "");
            if (code) {
              start = null;
              end = null;
            }
          }
        }
        if (start && end) {
          for (let j = start; j <= end; j++) {
            commentLines.push(j);
          }
        }
      }
      if (!str_) {
        for (let j = 0; j < codeLines.length; j++) {
          if (commentLines.indexOf(j + 1) == -1) {
            mappings[j + 1] = [j + 1];
          }
        }
        return mappings;
      }
    }
  }

  for (var i = 0; i < str_.split(";").length; i++) {
    mappingList.push(-1);
  }

  while (str.length > 0) {
    if (str.charAt(0) === ";") {
      generatedLine++;
      str = str.slice(1);
    } else if (str.charAt(0) === ",") {
      str = str.slice(1);
    } else {
      temp = base64VLQ.decode(str);
      str = temp.rest;

      if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
        // Original source.
        temp = base64VLQ.decode(str);

        str = temp.rest;
        if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
          throw new Error("Found a source, but no line and column");
        }

        // Original line.
        temp = base64VLQ.decode(str);
        previousOriginalLine = previousOriginalLine + temp.value;
        let preLineIndex = previousOriginalLine + 1;
        if (Object.keys(mappings).indexOf(preLineIndex.toString()) == -1) {
          mappings[preLineIndex] = [];
        }
        if (
          mappings[preLineIndex].indexOf(generatedLine) == -1 &&
          commentLines.indexOf(generatedLine) == -1
        ) {
          mappings[preLineIndex].push(generatedLine);
        }

        // if (mappingList[generatedLine] == -1) {
        //   mappingList[generatedLine] = preLineIndex
        // }

        str = temp.rest;
        if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
          throw new Error("Found a source and line, but no column");
        }

        // Original column.
        temp = base64VLQ.decode(str);
        str = temp.rest;
      }
    }
  }
  return mappings;
};
